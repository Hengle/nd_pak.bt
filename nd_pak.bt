//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: nd_pak.bt
//   Authors: alphaZomega
//   Version: 0.4
//   Purpose: Reads Naughty Dog pak files
//  Category: 
// File Mask: *.pak
//  ID Bytes: 79 0A 00 00
//   History: February 26, 2023
//    Thanks: icemesh
//------------------------------------------------
LittleEndian();
BitfieldDisablePadding();

local int i <hidden=true>, j <hidden=true>, k <hidden=true>, l <hidden=true>, w <hidden=true>, matchSize <hidden=true>, temp <hidden=true>, theColor <hidden=true>;
local int jointsPageId <hidden=1> = -1, jointsDescId <hidden=1> = -1;
local string s <hidden=true>;
local uint start <hidden=true>;
local uint geoStart <hidden=true>;
local ubyte isTLOU2 <hidden=true> = false;
local ubyte isModded <hidden=true> = false;

local uint numPointerFixups <hidden=1> = ReadUInt(ReadUInt(28)+8);
local ushort PFMaxSize <hidden=1> = 50;
local ushort PFMaxDivs <hidden=1> = numPointerFixups / PFMaxSize + 1;
local uint PFWaypoints[PFMaxDivs] <hidden=1>; 
local ushort PFDivCounter <hidden=1>;
local uint PFixupAddrs[numPointerFixups] <hidden=1>;
local uint PFixupAddrs2[numPointerFixups] <hidden=1>;
local uint PFixupAddrs3[numPointerFixups] <hidden=1>;
local uint PFixupPage1s[numPointerFixups] <hidden=1>;
local uint PFixupPage2s[numPointerFixups] <hidden=1>;
local uint PFixupLocations[numPointerFixups] <hidden=1>;

int find(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

ubyte detectedString(uint tell) {
    local string str = ReadString(tell);
    if (sizeof(str) > 6 && RegExSearch(str, "[a-zA-Z]{3}", matchSize, 0) != -1)
        return true;
    return false;
}

void seekToNextOf(int64 toFind, ubyte is64) {
    if (is64)
        while(FTell()+8<=FileSize() && ReadInt64() != toFind)
            FSkip(1);
    else
        while(FTell()+4<=FileSize() && ReadInt() != toFind)
            FSkip(1);
}

typedef struct (uint addAmt) {
    if (addAmt) {
        uint64 offset;
        FSeek(offset+addAmt);
    } else {
        struct pointerFixup offset;
        FSeek(offset.absOffset);
    }
    string str;
    FSeek(startof(this)+8);
} StringRead <read=ReadStringRead>;
    
    string ReadStringRead(StringRead &s) { return s.str; }

typedef struct {
    string str;
} rString <read=ReadrString>;
    
    string ReadrString(rString &s) { return s.str; }

typedef byte BLANK <name=readBLANK, read=readBLANK>;

    string readBLANK(BLANK &ref) { return " ";}

void alignString() {
    temp = (4 - (FTell() % 4));
    if (temp != 4 && !ReadUByte())
        FSeek(FTell() + temp);
}

struct  //size 0x2C
{
	uint32 m_magic;					    //0x0 0x00000A79
	uint32 m_hdrSize;					//0x4 header size
	uint32 m_pakLoginTableIdx;		    //0x8 idx of the page storing the PAK_LOGIN_TABLE
	uint32 m_pakLoginTableOffset;		//0xC relative offset PAK_LOGIN_TABLE = PakPageHeader + m_pakLoginTableOffset; //its a ResItem 
	uint32 m_pageCt;					//0x10 page count. Total number of pages in the package
	uint32 m_pPakPageEntryTable;		//0x14 ptr to the PakPageEntry array/table
	uint32 m_numPointerFixUpPages;	    //0x18 always 0x8
	uint32 m_pointerFixUpTableOffset;   //0x1C ptr to the PointerFixUpTable table
	uint32 m_datasize;			        //0x20 size of texture section after all the pages
	uint32 m_unk6;					    //0x24 no idea
	uint32 m_unk7;					    //0x28 no idea
    start = m_hdrSize + m_hdrSize % 16; 
    //local uint64 m_textureBaseOffset = m_hdrSize + m_pageCt << 19;
} Header;

struct  //0xC 
{
	uint32 m_resPageOffset;						//0x0 absolute offset to the ResPage
	uint32 m_pageSize;							//0x4 page size
	uint32 m_owningPackageIndex;		        //0x8 
} PakPageEntry[Header.m_pageCt];

int getPFWaypointIndex(uint32 tell) { 
    local short div = PFDivCounter-1;
    while (tell < PFWaypoints[div / 2] && (div/2 > 0))
        div = div / 2;
    for (div; div>0; div--)
        if (tell >= PFWaypoints[div])
            return (int)(div * PFMaxSize);
    return 0;
}

typedef struct //0x8
{
	uint16 m_page1Idx;							    // 0x0 idx in the page table
	uint16 m_page2Idx;							    // 0x2 idx in the page table
	uint32 m_offset;								// 0x4 offset
    local uint atAddress = m_offset + PakPageEntry[m_page1Idx].m_resPageOffset; //165576
    FSeek(atAddress);
    uint64 offset <bgcolor=cBlack>;
    FSeek(startof(this)+8);
} PointerFixUpPageEntry <read=ReadPointerFixUpPageEntry>;

    string ReadPointerFixUpPageEntry(PointerFixUpPageEntry &e) {
        local string s;
        SPrintf(s, "%i", e.atAddress);
        return s;
    }

    int getPointerFixupLoc(uint64 offset) {
        local ushort k;
        for (k=getPFWaypointIndex(offset); k < PointerFixUpPage[0].m_numLoginPageEntries; k++) {
            if (PFixupAddrs[k] == offset)
                return PFixupLocations[k];
        }
        return -1;
    }

    int getPointerFixupPage(uint64 offset) {
        local ushort k;
        for (k=getPFWaypointIndex(offset); k < PointerFixUpPage[0].m_numLoginPageEntries; k++) {
            if (PFixupAddrs[k] == offset)
                return PFixupPage2s[k];
        }
        return -1;
    }
//5 1888370688
//4 1888395264
//3 1891467264
//2 1115045888
//12 216743936
//13 219226112
//14 439902208
//15 440426496
//16 659570688
//17 666738688
//18 900071424
//19 897335296
//20 1111687168
typedef struct {
    if (ReadUInt64())
        uint64 offset <fgcolor=cGreen, bgcolor=cBlack>;
    else
        uint64 offset;
    //local short page = getPointerFixupPage(startof(offset));
    local short page = -1;
    FSeek(getPointerFixupLoc(startof(offset)));
    if (FTell() > 0) {
        struct PointerFixUpPageEntry pFixup;
        page = pFixup.m_page2Idx;
    }
    if (page != -1) {
        local uint64 absOffset = offset + PakPageEntry[page].m_resPageOffset;
        FSeek(absOffset);
        if (detectedString(absOffset))
            string testString;
        else
            struct pointerFixup testPointer <size=8>;
    } else
        local uint64 absOffset = offset;
     FSeek(startof(offset)+8);
} pointerFixup <read=readPointerFixup>;

    string readPointerFixup(pointerFixup &p) {
        local string s;
        if (exists(p.testString))
            return p.testString;
        else if (exists(p.absOffset) && p.page != -1)
            SPrintf(s, "%u", p.offset + PakPageEntry[p.page].m_resPageOffset); //p.absOffset);
        else
            SPrintf(s, "%Lu", ReadUInt64(startof(p)));
        return s;
    }

//Sorts array in ascending order, then sorts array2 by array (from Che)
void quicksort( int low, int high, uint array[], uint array2[] ) {
    local int i = low;
    local int j = high;
    local int temp = 0;
    local int z = array[(low + high) / 2]; // Choose a pivot value
    local byte doArray2;
    if (exists(array2[1]))
        doArray2 = true;
    while( i <= j ) {       // Partition the data
        while( array[i] < z ) // Find member above
            i++;
        while( array[j] > z ) // Find element below
            j--;
        if( i <= j )  {
            // swap two elements 
            temp     = array[i];
            array[i] = array[j]; 
            array[j] = temp;
            if (doArray2) {
                temp     = array2[i];
                array2[i] = array2[j]; 
                array2[j] = temp;
            }
            i++; 
            j--;
        }
    }
    // Recurse
    if( low < j )  
        quicksort( low, j, array, array2 );
    if( i < high ) 
        quicksort( i, high, array, array2 ); 
}

FSeek(Header.m_pointerFixUpTableOffset);

struct //0xC
{
	uint32 m_pageEntryNumber;						// 0x0 0, 1, 2 ...
	uint32 m_dataOffset;							// 0x4 ptr to the table
	uint32 m_numLoginPageEntries;					// 0x8 number of login pages entries
    if (m_numLoginPageEntries) {
        FSeek(m_dataOffset);
        for (i=0; i<PointerFixUpPage.m_numLoginPageEntries; i++) {
            PFixupLocations[i] = FTell();
            PointerFixUpPageEntry Entry <bgcolor=cBlack>;
            PFixupAddrs[i] = Entry.atAddress; 
            PFixupAddrs2[i] = Entry.atAddress; 
            PFixupAddrs3[i] = Entry.atAddress;
            PFixupPage1s[i] = Entry.m_page1Idx;
            PFixupPage2s[i] = Entry.m_page2Idx;
        }
        FSeek(startof(this)+12);
    }
} PointerFixUpPage[Header.m_numPointerFixUpPages] <optimize=false>;


quicksort(0, numPointerFixups-1, PFixupAddrs, PFixupPage2s); //Sort PointerFixups by their addresses
quicksort(0, numPointerFixups-1, PFixupAddrs2, PFixupPage1s);
quicksort(0, numPointerFixups-1, PFixupAddrs3, PFixupLocations);

for (i=0; i<numPointerFixups; i++) {
    if (i == PFMaxSize * PFDivCounter) {
        PFWaypoints[PFDivCounter] = PFixupAddrs[i];
        PFDivCounter++;
    }
}

ubyte detectedFloat(uint tell) {
    return ((Abs(ReadFloat(tell)) < 100000 && Abs(ReadFloat(tell)) > 0.00000001)); //ReadFloat(tell) == 0 || 
}

enum dxFormat {
	kInvalid = 0,
	kR32G32B32A32Float = 2,
	kR32G32B32A32Uint = 3,
	kR32G32B32A32Sint = 4,
	kR32G32B32Float = 6,
	kR32G32B32Uint = 7,
	kR32G32B32Sint = 8,
	kR16G16B16A16Float = 0xA,
	kR16G16B16A16Unorm = 0xB,
	kR16G16B16A16Uint = 0xC,
	kR16G16B16A16Snorm = 0xD,
	kR16G16B16A16Sint = 0xE,
	kR32G32Float = 0x10,
	kR32G32Uint = 0x11,
	kR32G32Sint = 0x12,
	kR32G8X24 = 0x13,
	kD32S8X24 = 0x14,
	kR32X8X24 = 0x15,
	kX32G8X24 = 0x16,
	kR10G10B10A2Unorm = 0x18,
	kR10G10B10A2Uint = 0x19,
	kR11G11B10Float = 0x1A,
	kR8G8B8A8Unorm = 0x1C,
	kR8G8B8A8UnormSrgb = 0x1D,
	kR8G8B8A8Uint = 0x1E,
	kR8G8B8A8Snorm = 0x1F,
	kR8G8B8A8Sint = 0x20,
	kR16G16Float = 0x22,
	kR16G16Unorm = 0x23,
	kR16G16Uint = 0x24,
	kR16G16Snorm = 0x25,
	kR16G16Sint = 0x26,
	kR32Typeless = 0x27,
	kD32Float = 0x28,
	kR32Float = 0x29,
	kR32Uint = 0x2A,
	kR32Sint = 0x2B,
	kR24G8Typeless = 0x2C,
	kD24S8 = 0x2D,
	kR24X8Unorm = 0x2E,
	kX24G8 = 0x2F,
	kR8G8Unorm = 0x31,
	kR8G8Uint = 0x32,
	kR8G8Snorm = 0x33,
	kR8G8Sint = 0x34,
	kR16Typeless = 0x35,
	kR16Float = 0x36,
	kD16Unorm = 0x37,
	kR16Unorm = 0x38,
	kR16Uint = 0x39,
	kR16Snorm = 0x3A,
	kR16Sint = 0x3B,
	kR8Unorm = 0x3D,
	kR8Uint = 0x3E,
	kR8Snorm = 0x3F,
	kR8Sint = 0x40,
	kA8Unorm = 0x41,
	kR1unorm = 0x42,
	kBc1Typeless = 0x46,
	kBc1Unorm = 0x47,
	kBc1UnormSrgb = 0x48,
	kBc2Typeless = 0x49,
	kBc2Unorm = 0x4A,
	kBc2UnormSrgb = 0x4B,
	kBc3Typeless = 0x4C,
	kBc3Unorm = 0x4D,
	kBc3UnormSrgb = 0x4E,
	kBc4Typeless = 0x4F,
	kBc4Unorm = 0x50,
	kBc4Snorm = 0x51,
	kBc5Typeless = 0x52,
	kBc5Unorm = 0x53,
	kBc5Snorm = 0x54,
	kB5G6R5Unorm = 0x55,
	kB5G5R5A1Unorm = 0x56,
	kB8G8R8A8Unorm = 0x57,
	kB8G8R8X8Unorm = 0x58,
	kR10G10B10A2Unorm_2 = 0x59,
	kB8G8R8A8Unorm_2 = 0x5A,
	kB8G8R8A8UnormSrgb = 0x5B,
	kB8G8R8X8Typeless = 0x5C,
	kB8G8R8X8UnormSrgb = 0x5D,
	kBc6Typeless = 0x5E,
	kBc6Uf16 = 0x5F,
	kBc6Sf16 = 0x60,
	kBc7Typeless = 0x61,
	kBc7Unorm = 0x62,
	kBc7UnormSrgb = 0x63,
	kB16G16R16A16Float = 0x64
};

typedef struct  {
	uint32		field_0;			///< <c>0x00</c>:
	uint32		field_4;			///< <c>0x04</c>:
	uint32		m_pakOffset;		///< <c>0x08</c>: offset in the pak
	uint32		field_C;			///< <c>0x0C</c>:
	uint32		m_vramSize;			///< <c>0x10</c>: texture size
	uint32		field_14;			///< <c>0x14</c>:
	uint64		VRAM_DESC_Hash; //m_uid;				///< <c>0x18</c>: StringId ?
	uint32		field_20;			///< <c>0x20</c>:
	uint32		m_type;				///< <c>0x24</c>:
	dxFormat	m_dxFormat;			///< <c>0x28</c>: 
	uint32		field_2C;			///< <c>0x2C</c>:
	uint32		m_mipCount;			///< <c>0x30</c>: mip count
	uint32		m_width;			///< <c>0x34</c>: width
	uint32		m_height;			///< <c>0x38</c>: height
	uint32		field_3C;			///< <c>0x3C</c>:
	uint64		m_streamFlags;		///< <c>0x40</c>:
    //uint64 VRAM_DESC_Hash;
    //uint uknInt[10];
    StringRead texturePath(0);
    string path;
    FSeek(m_pakOffset + PakPageEntry[Header.m_pageCt-1].m_resPageOffset + PakPageEntry[Header.m_pageCt-1].m_pageSize);
    if (FTell()+m_vramSize <= FileSize())
        struct {
            FSkip(m_vramSize-1);
            ubyte end;
        } ImageData;
    FSeek(startof(path) + sizeof(path));
} VRAM_DESC  <read=ReadVRamDesc>;

typedef struct {
    uint64 vramCount;
    struct sVRAMs {
        struct {
            pointerFixup Pointer[vramCount] <optimize=false>;
        } Pointers;
        for (j=0; j<vramCount; j++) {
            FSeek(Pointers.Pointer[j].absOffset + 32);
            VRAM_DESC VRAM;
        }
        FSeek(startof(this)+sizeof(Pointers));
    } VRAMs <size=SizeVRAMs>;
} VRAM_DESC_TABLE;

    int SizeVRAMs(sVRAMs &v) { return vramCount * 8; } 

typedef struct  {
	int			m_numTextureEntries;//0x4
	uint		    m_unk;
	pointerFixup	hashesOffs;//0x8
	pointerFixup    textureNamesOffs;//0x10
    pointerFixup	vramListOffs; //0x1C
    struct {
        pointerFixup Pointer[m_numTextureEntries] <optimize=false>;
    } Pointers;
    FSeek(textureNamesOffs.absOffset);
    struct {
        StringRead TextureName(0)[m_numTextureEntries] <optimize=false>;
    } TextureNames;
    for (j=0; j<m_numTextureEntries; j++) {
        FSeek(Pointers.Pointer[j].absOffset);
        struct VRAM_DESC VRAM;
    }
    FSeek(startof(Pointers) + sizeof(Pointers));
    
} TEXTURE_TABLE;

typedef struct  {
    if (!exists(loginCount)) {
        uint loginCount;
        uint32 padding;
        local ubyte ct <hidden=true>;
        struct { 
            uint32 page;
            uint32 offset;
        } LoginTableEntry[loginCount-1];
        uint32 ukn, ukn;
        FSeek(startof(LoginTableEntry[0]));
        struct loginTable {
            for (ct=0; ct<loginCount-1; ct++) {
                FSeek(LoginTableEntry[ct].offset + PakPageEntry[LoginTableEntry[ct].page].m_resPageOffset);
                start = PakPageEntry[LoginTableEntry[ct].page].m_resPageOffset;
                if (FTell() < FileSize() )
                    struct ResItem login <name=ReadResItemName>;
            }
            FSeek(startof(LoginTableEntry)+loginCount*8);
        } LoginTable <size=8>;
        FSeek(startof(LoginTableEntry)+loginCount*8);
    }
} PAK_LOGIN_TABLE;

typedef struct {
    pointerFixup effectStart;
    uint64 ukn;
    
    FSeek(effectStart.absOffset);
    int32 ukn, ukn;
    int64 ukn;
    pointerFixup dataTableOffs;
    int32 ukn, ukn;
    struct {
        FSkip(207);
        ubyte end;
    } jsStructs[10] <optimize=true>;
    
    FSeek(dataTableOffs.absOffset);
    struct {
        
    } dataTable;
    

    FSeek(startof(this)+8);
} EFFECT;

typedef struct  {
    uint effectCount;
    uint ukn;
    pointerFixup effectsOffs;
    pointerFixup fxNameOffs;
    pointerFixup namesTableOffs;
    
    FSeek(effectsOffs.absOffset);
    if (effectsOffs.offset)
        struct {
            struct {
                pointerFixup effectPointer;
                uint64 ukn;
                uint64 hash;
                FSeek(effectPointer.absOffset);
                struct EFFECT Effect;
                FSeek(startof(this)+24);
            } effect[effectCount] <optimize=false>;
        } effects;

    FSeek(fxNameOffs.absOffset);
    if (fxNameOffs.offset)
        struct {
            uint64 ukn, ukn;
            StringRead characterShaderName(0);
            StringRead characterShaderName(0);
        } fxNames;

    FSeek(namesTableOffs.absOffset);
    if (namesTableOffs.offset)
        struct {
            uint32 count;
            uint32 ukn, ukn, ukn;
            for (w=0; w<count; w++)
                StringRead name(0);
        } names;
    FSeek(startof(namesTableOffs)+8);
    
} EFFECT_TABLE <size=8>;

typedef struct {
    pointerFixup startOffs;
    uint64 reserved;
    FSeek(startOffs.absOffset);
    pointerFixup listOffs;
    pointerFixup firstListEntryOffs;
    pointerFixup midListEntryOffs;
    FSeek(listOffs.absOffset);
    uint b, c, d, e;
    local ushort numJSegments = Page[jointsPageId].PageEntry[jointsDescId].Item.Joints.numJSegments;
    
    FSeek(midListEntryOffs.absOffset);
    struct {
        for (w=0; w<numJSegments; w++)
            struct {
                local ubyte idx <hidden=1> = w;
                pointerFixup boneMapOffs;
                FSeek(boneMapOffs.absOffset);
                local ubyte boneCount;
                while(ReadUShort() != 0) {
                    ubyte boneID <read=ReadBoneIDByte>;
                    boneCount++;
                }
                FSeek(startof(this)+8);
            } BoneMap;
    } BoneMaps;

    FSeek(firstListEntryOffs.absOffset);
    struct {
        for (w=0; w<numJSegments; w++)
            struct {
                local ubyte idx <hidden=1> = w;
                pointerFixup weightsOffs;
                FSeek(weightsOffs.absOffset);
                if (BoneMaps.BoneMap[w].boneCount)
                    ushort value[BoneMaps.BoneMap[w].boneCount] <open=true, optimize=false>;
                FSkip(-1); BLANK blank;
                FSeek(startof(this)+8);
            } BoneValue;
    } BoneValues;

    
   // pointerFixup ptr[16] <optimize=false>;
} SKELETON_FLIPDATA;

typedef struct  //0x20 
{
	StringRead m_itemNameOffset(start);	//0x0 item name. relative offset PakPageHeader + m_itemNameOffset;
	StringRead m_itemTypeOffset(start);	//0x8 item type name. relative offset PakPageHeader + m_itemTypeOffset; PM_COLLECTION_2 || RAW_DATA etc
	uint32 m_unkNumber;	
    
    if (ReadUInt(FTell()+12)==74565) {
        uint32  m_unused[7] <bgcolor=cYellow>;
        isTLOU2 = true;
    } else {
        uint32 m_unused[3] <bgcolor=cYellow>;				//0x14 always 00 01 23 45 
    }

    switch(m_itemTypeOffset.str) {
        case "GEOMETRY_1":
            geoStart = FTell();
            struct GEOMETRY_1 Geometry <size=112>;
            break;
        case "JOINT_HIERARCHY":
            jointsPageId = i;
            jointsDescId = l;
            struct JOINT_HIERARCHY Joints;
            break;
        case "VRAM_DESC":
            struct VRAM_DESC VRAM <read=ReadVRamDesc>;
            break;
        case "VRAM_DESC_TABLE":
            struct VRAM_DESC_TABLE VRAMTable;
            break;
        case "TEXTURE_TABLE":
            struct TEXTURE_TABLE TextureTable;
            break;
        case "PAK_LOGIN_TABLE":
            struct PAK_LOGIN_TABLE PakLogin;
            break;
        case "SKELETON_FLIPDATA":
            struct SKELETON_FLIPDATA FlipData;
        case "EFFECT_TABLE":
            struct EFFECT_TABLE Effect_Table;
            break;
        default:
            break;
    }
    
    FSeek(startof(m_unused)+sizeof(m_unused));
    if (ReadUInt64(FTell()+20) != 320254236500805) {
        if (FTell() < FileSize()-28) {
            struct TEST {
                while(ReadUInt64(FTell()+20) != 320254236500805 && ReadUInt64(FTell()+18) != 320254236500805) { //ctr < 600 && 
                    if (detectedString(FTell())) {
                        struct rString uknString;
                        alignString();
                    } else if (FTell() % 8 == 0 && ReadInt64() < FileSize() && ReadInt64() >= 0) {
                        temp = getPointerFixupPage(FTell());
                        if (temp != -1)
                            StringRead Pointer(PakPageEntry[temp].m_resPageOffset);
                        else
                            uint64 uknInt64;
                    } else if(Abs(ReadFloat()) < 10000000 && Abs(ReadFloat()) > 0.00000001) {
                        float uknFloat;
                    } else
                        int uknInt;
                }
            } Test <size=28>;
        }
    }
} ResItem <read=ReadResItem>;//, name=ReadResItemName>;

    string ReadResItem(ResItem &r) { 
        if (exists(r.Item) && r.m_itemTypeOffset.str == "VRAM_DESC")
            return ReadVRamDesc(r.Item.VRAM);
        return r.m_itemNameOffset.str; 
    }
    
    string ReadResItemName(ResItem &r) { return r.m_itemTypeOffset.str; }
    
    int GetSizeTest(TEST &t) { return mySize; }

    string ReadVRamDesc(VRAM_DESC &v) { return v.path; }

typedef struct //0x10 
{
	StringRead m_name(start);	//0x0 same as the ResItem name... This field is usually used by animations
	uint32 m_resItemOffset;					//0x8 relative offset. -> ResItem = PakPageHeader + m_pakLoginItemOffset
	uint32 m_padding;						//0xC always 00 01 23 45
    FSeek(m_resItemOffset + start);
    ResItem Item;
    FSeek(startof(this)+16);
} ResPageEntry <read=ReadResPageEntry, name=ReadResPageEntryName, optimize=false>;
    
    string ReadResPageEntry(ResPageEntry &r) {
        return r.m_name.str;
    }

    string ReadResPageEntryName(ResPageEntry &r) {
        return r.Item.m_itemTypeOffset.str;
    }

typedef struct //0x14
{
    start = startof(this);
	uint64 m_unused;							//0x0	0xDEADBEEFDEADBEEF
	uint32 m_unk;								//0x8	always 0 ?
	uint32 m_pageSize;							//0xC	size maybe from the start of PakPageHeader
	uint16 m_packageOwningIndex;				//0x10
	uint16 m_numPageHeaderEntries;				//0x12	number of pointers in the table
    if (m_numPageHeaderEntries)
        for (l=0; l<m_numPageHeaderEntries; l++)
            ResPageEntry PageEntry;
    struct {
        if (m_pageSize) {
            FSkip(m_pageSize-(FTell()-startof(parentof(this)))-1);
            ubyte end;
        }
    } PageData;
} ResPage;

typedef struct {
    uint version;
    uint ukn;
    uint ukn;
    uint ukn;
    uint numJSegments;
    uint nodeCount;
    uint boneCount1;
    uint boneCount2;
    pointerFixup matsOffset;
    pointerFixup skeletonFlipDataOffset;
    pointerFixup jsInfoOffset;
    pointerFixup namesOffset;

    pointerFixup riggingGroupsNamesOffs;
    pointerFixup riggingGroupsOffs;
    pointerFixup unknownFloatsOffs;
    pointerFixup unknown3;
    
    if (riggingGroupsOffs.absOffset) {
        FSeek(riggingGroupsOffs.absOffset);
        struct {
            uint numRiggingGroups;
            uint ukn;
            pointerFixup groupsOffset;
            FSeek(groupsOffset.absOffset);
            struct {
                struct {
                    StringRead name(0);
                    uint uknInt, uknInt, uknInt;
                    float uknFlt;
                } RiggingGroup[numRiggingGroups] <optimize=false>;
            } RiggingGroups;
            if (riggingGroupsNamesOffs.absOffset) {
                FSeek(riggingGroupsNamesOffs.absOffset);
                struct {
                    struct {
                        uint hash, ukn;
                        StringRead name(0);
                    } RiggingGroupName[numRiggingGroups] <optimize=false>;
                } RiggingGroupsNames;
            }
            FSeek(startof(this)+16);
        } RiggingGroups;
    }

   if (unknownFloatsOffs.absOffset) {
        FSeek(unknownFloatsOffs.absOffset);
        float uknFloats[35];
    }
    
   if (unknown3.absOffset) {
        FSeek(unknown3.absOffset+132);
        StringRead unknown3Test(0);
    }


    FSeek(matsOffset.absOffset);
    
    struct {
        uint64 uknHash, uknHash;
        ushort nodeCount;
        ushort transformCount;
        ushort uknCount;
        ushort uknShort;
        uint uknInt, uknInt;
        uint headerSize;
        uint ukn;
        uint uknFloatsOffs;
        uint aOffs;
        uint bOffs;
        uint cOffs;
        uint ukn;
        uint parentingOffset;
        
        //struct {
        //    uint headerSize, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
        //} ints[4];
        //struct {
        //    uint count, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
        //} transformsHdr;
        FSeek(startof(JointsInfo)+JointsInfo.aOffs);
        struct {
            ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
            ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
        } tableA;

        FSeek(startof(JointsInfo)+JointsInfo.bOffs);
        struct {
            ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
            if (ukn[1]) {
                struct {
                    ushort ukn, ukn, ukn, ukn, ukn, hdrSize, ukn, ukn;
                    ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
                } exHeader <open=true>;
                ushort uknMap[exHeader.hdrSize / 2] <read=ReadBoneID>;
                ushort boneMap[tableB.exHeader.ukn[8]] <read=ReadBoneID>;
            }
        } tableB;

        FSeek(startof(JointsInfo)+JointsInfo.cOffs);
        struct {
            ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
        } tableC;
        
        FSeek(tableC.ukn[1] + startof(this));
        ubyte tes;
        FSeek(tableC.ukn[2] + startof(this));
        ubyte tes;
        FSeek(tableC.ukn[5] + startof(this));
        ubyte tes;
        FSeek(tableC.ukn[6] + startof(this));
        ubyte tes;

    } JointsInfo;

    FSeek(startof(JointsInfo)+JointsInfo.ukn[0]);
    struct {
        struct {
            uint test;
        } uknStruct;//[JointsInfo.transformCount] <optimize=false, read=ReadBoneTransform>;
    } uknStructs;

    FSeek(startof(JointsInfo)+JointsInfo.headerSize);
    struct {
        struct boneTransform {
            local ushort idx <hidden=true> = (FTell() - startof(transform[0])) / 48;
            float scale[4];
            float rotation[4];
            float position[4];
        } transform[JointsInfo.transformCount] <optimize=false, read=ReadBoneTransform>;
    } transforms  <fgcolor=cLtPurple>;
    
    //maybe rotation mats
    FSeek(startof(JointsInfo)+JointsInfo.uknFloatsOffs);
    struct {
        struct {
            float x, y, z, w;
            float x, y, z, w;
            float x, y, z, w;
        } matrix[nodeCount];
        /*uint ukn[7];
        uint ids[nodeCount];
        seekToNextOf(1065353216, false);
        struct boneFloats {
            local ushort idx <hidden=true> = (FTell() - startof(BoneFloats[0])) / 48;
            float ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
        } BoneFloats [nodeCount] <optimize=false, read=readBoneFloats>;*/
    } floats  <fgcolor=cLtYellow>;
    

    FSeek(JointsInfo.parentingOffset + startof(JointsInfo));
    struct {
        uint ukn;
        uint headerSize;
        uint uknSize0;
        uint uknSize1;
        uint uknSize2;
        uint hashesPlusHeaderSz;
        //uint hashes[(hashesPlusHeaderSz-36)/4];
        FSeek(startof(this)+hashesPlusHeaderSz);
        
        struct boneParentInfo {
            local ushort idx <hidden=true> = (FTell() - startof(bones[0])) / 16;
            int groupID; //???
            int parentID;
            int childID;
            int chainID;
        } bones [nodeCount] <optimize=false, read=ReadBoneParentInfo>;

        /*local uint nonHelperCount = 1;
        for (w=1; w<nodeCount; w++){
            if (bones[w].parentID == -1) {
                Printf("%i\n", w);
                bones[w].invalid = true;
            } else if (bones[bones[w].parentID].invalid)
                bones[w].invalid = true;
        } for (w=1; w<nodeCount; w++) {
            if (bones[w].invalid)
                nonHelperCount++;
        }*/

    } parenting <fgcolor=cLtRed>;
    
    FSeek(jsInfoOffset.absOffset);
    struct {
        struct {
            uint32 hash, ukn;
            StringRead name(0);
        } JointSegment[numJSegments] <optimize=false>;
    } JointSegments;
    

    FSeek(namesOffset.absOffset);
    struct {
        for (j=0; j<nodeCount; j++) {
            uint64 uknHash <hidden=1>;
            struct StringRead name(0);
            //transforms.transform[k].name = name.str;
        }
    } names  <fgcolor=cLtGreen>;

    FSeek(startof(namesOffset)+8);
    
} JOINT_HIERARCHY;

    string ReadBoneTransform(boneTransform &b) { return parentof(parentof(b)).names.name[b.idx].str; }
    
    string ReadBoneParentInfo(boneParentInfo &b) { return parentof(parentof(b)).names.name[b.idx].str; }
    
    //string readBoneFloats(boneFloats &b) { return parentof(parentof(b)).names.name[b.idx].str; }

    string ReadBoneID(ushort &b) { 
        if (jointsDescId != -1 && exists(Page[jointsPageId].PageEntry[jointsDescId].Item.Joints.names.name[b]))
            return Page[jointsPageId].PageEntry[jointsDescId].Item.Joints.names.name[b].str;
        local string s; SPrintf(s, "%i", b);
        return s;
    }



typedef struct
{
	uint32		m_version;///< <c>0x00</c>: always 0x1E ?
	uint32		m_isForeground;///< <c>0x04</c>: se to 1 if its an actor
	int32		m_numSubMeshDesc;///< <c>0x08</c>:
	uint32		m_LODCount;///< <c>0x0C</c>:
	uint32		m_unk4;///< <c>0x10</c>:
	uint32		m_numTextures;///< <c>0x14</c>:
	uint32		m_numShaders;///< <c>0x18</c>:
	uint32		m_unk6;///< <c>0x1C</c>:
	uint32		m_unk7;///< <c>0x20</c>:
	uint32		m_numMaterials;///< <c>0x24</c>:
    pointerFixup SubmeshesOffs;
    pointerFixup LODDescsOffs;
    uint64 ukn0;
    pointerFixup textureDescsOffs;
    pointerFixup shaderDescsOffs;
    uint64 ukn3;
    pointerFixup uknFloatsOffs;
    pointerFixup materialDescsOffs;
    
    if (!isTLOU2) {
        FSeek(LODDescsOffs.absOffset);
	    struct LODDESCS {
            local uint totalVertCount, totalIndexCount;
            struct {
                pointerFixup LODHeaderOffs;
                FSeek(LODHeaderOffs.absOffset);
                struct {
                    uint unknown;
                    uint submeshCount;
                    uint64 data64;
                    StringRead collectionName(0);
                    pointerFixup firstSubmeshDescOffs;
                    pointerFixup uknBytesOffs;
                    int uknData[26];
                    FSeek(firstSubmeshDescOffs.absOffset);
                    local ubyte sb <hidden=true>;
                    local uint vertCount, indexCount;
                    for (sb=0; sb<submeshCount; sb++){
                        struct {
                            pointerFixup submeshOffset;
                            int submeshIndex;
                            int uknInt;
                            FSeek(submeshOffset.absOffset);
                            struct SubMeshDesc submesh;
                            FSeek(startof(this)+16);
                            vertCount += submesh.SubmeshInfo.m_numVertexes;
                            indexCount += submesh.SubmeshInfo.m_numIndexes;
                        } submeshDescTbl;// <size=16>;
                    }
                    
                    FSeek(uknBytesOffs.absOffset);
                    ubyte uknBytes[15];
                    totalVertCount += vertCount;
                    totalIndexCount += indexCount;
                    FSeek(startof(uknData)+sizeof(uknData));
                } LODDesc <open=true>;
                FSkip(-1); BLANK blank;
                FSeek(startof(this)+8);
                
            } LODDesc[m_LODCount] <optimize=false>;
        } LODDescs <size=sizeLODDESCS>;
    
        FSeek(textureDescsOffs.absOffset);
        struct {
            struct textureDesc {
                StringRead tgaPath(0);
                uint64 VRAM_DESC_Hash;
                uint64 ukn64, ukn64, ukn64;
            } TextureDesc[m_numTextures] <optimize=false, read=ReadTextureDesc>;
        } TextureDescs;
    
        FSeek(uknFloatsOffs.absOffset);
        struct {
            while(ReadUInt() == 0 || detectedFloat(FTell()))
                float uknFloat;
            //}uknFloats[386];
        } uknFloats;
    
        FSeek(shaderDescsOffs.absOffset);
        struct {
            struct shaderDesc ShaderDesc[m_numShaders] <optimize=false>;
        } ShaderDescs;
    
        FSeek(materialDescsOffs.absOffset);
        struct {
            local ushort totalSz <hidden=true>;
            struct {
                int hash;
                uint paramDescCount;
                pointerFixup paramsDescsOffs;
                FSeek(paramsDescsOffs.absOffset);
                //struct {
                    struct {
                        int hash, hash, hash;
                        uint size, uknInt;
                        uint paramCount;
                        pointerFixup paramsOffs;
                        local ushort startOffs = totalSz;
                        totalSz += size;
                        FSeek(paramsOffs.absOffset);
                        
                        struct Param {
                            StringRead paramName(0);
                            StringRead paramName2(0);
                            ushort ukn, ukn, ukn, ukn; 
                            ushort floatsOffset; 
                            ushort paramSize; 
                            ushort ukn, ukn;
                            
                            //FSeek(uknFloatsOffs.absOffset + startOffs + floatsOffset); //not really
                            //float value[paramSize/4] <optimize=false>;//, bgcolor=cGreen>;
    
                            FSeek(startof(this)+32);
                        } params[paramCount] <optimize=false, read=ReadParam>;
    
                        FSeek(startof(this)+32);
                    } paramsDesc[paramDescCount] <optimize=false>;
                //} paramsDescs;
                FSeek(startof(this)+16);
            } MaterialDesc[m_numMaterials] <optimize=false>;
        } MaterialDescs;
    }
    FSeek(SubmeshesOffs.absOffset);
    struct {
	    struct SubMeshDesc	m_pSubMeshDescTable[m_numSubMeshDesc] <optimize=false>;///< <c>0x28</c>:
    } SubmeshDescs;

    /*FSeek(uknFloatsOffs.absOffset);
    struct {
        struct {
            float flt, flt, flt, flt;
        } vector[10];
    } UknFloats;*/
    FSeek(startof(materialDescsOffs)+16);
} GEOMETRY_1;

    string ReadParam(Param &p) { return p.paramName2.str; }
    
    string ReadTextureDesc(textureDesc &t) { return t.tgaPath.str; }

    int sizeLODDESCS(LODDESCS &l) { return m_LODCount*8; }


string GetSFix(int x, ubyte exp) {
    local int c = Abs(x);
    local byte sign = 1; 
    if (x < 0) {
        c = x - 1;
        c = ~c;
        sign = -1;
    }
    SPrintf(s, "%g", ( (1.0 * c) / Pow(2, exp) ) * sign);
    return s;
}

typedef struct //0xB0; 
{
    struct {
        local uint index <hidden=1> = (FTell() - startof(parentof(this))) / 176;
        if (isTLOU2) {
            float bbox[8];
            StringRead      m_name(0);
            uint64          ukn;
            pointerFixup    m_pStreamDesc;
            uint64          ukn;
            pointerFixup    m_pIndexes;
            pointerFixup    shaderDescOffs;
            uint64          ukn;
            pointerFixup    skinDataOffs;
            uint64          ukn, ukn;
            pointerFixup    normalsRecalcOffset;
            StringRead      uknString(0);
	        int32		    m_numVertexes;
	        int32	    	m_numIndexes;
            uint32          m_numStreamSource;
            uint32          m_numDefaultStreams;
            int32 uknInt, uknInt;
            uint64 ukn;
            int32 uknInt, uknInt, uknInt, uknInt;
        } else {
	        uint32		field_0;
	        uint32		field_4;
	        StringRead  m_name(0);
            uint32		field_10;
	        uint32      field_14;
            uint32      ukn;
	        uint32		field_1C;
	        uint32		field_20;
	        int32		m_numVertexes;
	        int32		m_numIndexes;
	        uint32		m_numStreamSource;
	        int32		m_numDefaultStreams;
	        uint32		field_34;
	        pointerFixup m_pStreamDesc; //floats
	        uint32		field_40;
	        uint32		field_44;
	        pointerFixup m_pIndexes; //uint16
	        pointerFixup shaderDescOffs;//material related;
	        uint32		m_submeshIndex;
	        uint32		field_5C;
	        uint32		field_64;
	        uint32		field_68;
	        pointerFixup skinDataOffs;
	        uint32		field_74;
	        uint32		field_78;
	        uint32		field_7C;
	        uint32		field_80;
	        uint32		field_84;
	        uint32		field_88;
	        pointerFixup normalsRecalcOffset;
	        uint32		field_94;
	        uint32		field_98; //StringRead		field_98(start);
	        StringRead unknownString1(0);
	        uint32		field_A4;
	        uint32		field_A8; //StringRead		field_A8(start);
	        StringRead unknownString2(0);
        }
    } SubmeshInfo;
    


    
    typedef struct  {
        uint m_unkPtr; //FloatDesc
        uint m_unkPtr2; //floats
        uint m_unkData;
    } StreamSource;
    
    //local short vertsPageIdx = Header.m_pageCt-1;

    FSeek(SubmeshInfo.m_pStreamDesc.absOffset);// + 72*SubmeshInfo.index; 
    
    local ubyte foundNormals <hidden=true>;
    local ubyte foundUV1 <hidden=true>;


    for (j=0; j<SubmeshInfo.m_numStreamSource; j++) {
        struct StreamDesc {
            if (isTLOU2) {
                pointerFixup m_bufferOffset;
                uint numVerts;
                uint bitStride;
                uint bufferSize;
                struct T2FloatDesc {
                    enum <byte> T2ComponentType {
                        T2_PositionsF = 0,
                        T2_UVs = 1,
                        T2_Normals = 2,
                        T2_Tangents = 3,
                        T2_UV2s = 11,
                        T2_Positions_40b = 64,
                        Unk_2x_27b = 65,
                        Unk_1x_32b = 130,
                        Unk_1x_13b = 68,
                        Unk_0x_0b = 70,
                        T2_UVs_ukn0 = 75,
                        T2_UVs_ukn1 = 76,
                        
                    } m_floatType;
                    ubyte m_unk2;
                    ubyte m_unk3 : 4; //ComponentType floatType : 4;
                    ubyte m_stride : 4;
                    //local ubyte stride <hidden=0> = (uint)(bufferSize/numVerts);
                    ubyte m_unk4;
                    //ComponentType floatType2 : 4;
                } T2compInfo;
                ubyte sizes[4];
                ubyte ukn[4];
                
                float qScale[4];
                float qOffs[4];
                
                FSeek(m_bufferOffset.absOffset);
                SetBackColor((Random(255)<<16) | (Random(255)<<8) | (Random(255)));
                    
                if (T2compInfo.m_stride)
                    struct TLOU2Vert {
                        if (T2compInfo.m_floatType == 0) {
                            float X, Y, Z;
                        } else {
                            uint64 x : sizes[0];
                            uint64 y : sizes[1];
                            uint64 z : sizes[2];
                            uint64 w : sizes[3];
                        }
                        //FSeek(startof(this)+T2compInfo.m_stride);
                    } vertices[numVerts] <optimize=true, read=ReadTLOU2Vert>;
                SetBackColor(cNone);
                
                FSeek(startof(this)+64);
            } else {
                ubyte m_numAttributes;
                ubyte m_unk;
                ushort m_stride;
                uint m_unk2;
                //ubyte m_unk3;
                //ushort m_unk4;
                
                pointerFixup compInfoOffs;
                FSeek(compInfoOffs.absOffset);
                struct FloatDesc {
                    ubyte m_unk;
                    ubyte m_unk2;
                    ubyte m_stride2;
                    enum <byte> ComponentType {
                        Vector3F_0 = 6,
                        Vector3F_1 = 12,
                        Vector4Half = 10,
                        NormalsTangents = 31,
                        UVs = 34,
                        Indices = 42,
                    } m_floatType;
                } compInfo <read=ReadFloatDesc>;
                FSeek(startof(compInfoOffs)+8);
                
                pointerFixup m_bufferOffset;
                
                FSeek(m_bufferOffset.absOffset);
        
                switch(compInfo.m_floatType) {
                    case 10:
                        struct {
                            hfloat x, y, z, w <hidden=1>; 
                        } positions[SubmeshInfo.m_numVertexes] <fgcolor=cGreen>;
                        break;
                    case 31:
                        if (!foundNormals) {
                            foundNormals = true;
                            struct{
                                ubyte A,B,C,D;
                            } normals[SubmeshInfo.m_numVertexes] <fgcolor=cAqua>;
                        } else {
                            struct{
                                ubyte A,B,C,D;
                            } tangents[SubmeshInfo.m_numVertexes] <fgcolor=cWhite>;
                        }
                        break;
                    case 34: //UVs
                        if (!foundUV1) {
                            foundUV1 = true;
                            struct {
                                hfloat U, V;
                            } UV1[SubmeshInfo.m_numVertexes] <fgcolor=cLtBlue>;
                        } else {
                            struct {
                                hfloat U, V;
                            } UV2[SubmeshInfo.m_numVertexes] <fgcolor=cLtBlue>;
                        }
                        break;
                    default:
                        if (m_stride == 12 && j == 0) {
                            struct {
                                float x, y, z; 
                            } positions[SubmeshInfo.m_numVertexes];
                        } else
                            uint vertices[SubmeshInfo.m_numVertexes] <fgcolor=cRed>;
                        break;
                }
                FSeek(startof(m_bufferOffset)+8);
            }
        } streamDesc <read=ReadStreamDesc>;
    }
    
    //unknown
    if (SubmeshInfo.normalsRecalcOffset.offset) {
        FSeek(SubmeshInfo.normalsRecalcOffset.absOffset);
        struct {
            uint numVerts;
            uint numIndices;
            pointerFixup ptr1;
            pointerFixup ptr2;
            pointerFixup ptr3;
            pointerFixup ptr4;
            FSeek(ptr1.absOffset);
            struct {
                ushort vertIndex[numVerts];
            } ptr1Indices  <fgcolor=cLtRed>;
            FSeek(ptr2.absOffset);
            struct {
                ushort vertIndex[numVerts];
            } ptr2Indices  <fgcolor=cLtBlue>;
            FSeek(ptr3.absOffset);
            struct {
                ushort vertIndex[numVerts];
            } ptr3Indices  <bgcolor=cLtGreen>;
            FSeek(ptr4.absOffset);
            struct {
                ushort vertIndex[numVerts];
            } ptr4Indices  <bgcolor=cLtYellow>;
            FSeek(startof(this)+40);
        } NormalsRecalculation <size=40>;
    }
    
    //weights
    if (SubmeshInfo.skinDataOffs.offset) {
        FSeek(SubmeshInfo.skinDataOffs.absOffset);
        struct {
            uint ukn, weightCount, ukn;
            ushort uknShort, uknShort;
            pointerFixup indicesOffs;
            pointerFixup weightsOffs;
            FSeek(weightsOffs.absOffset);
            struct {
                for (j=0; j<SubmeshInfo.m_numVertexes; j++) {
                    FSeek(weightsOffs.absOffset + ReadUInt(indicesOffs.absOffset + j*8 + 4));
                    // (23 & 1023) | (1227488 & 4194304) << 10
                    struct weightVert {
                        local uint weightTotal;
                        FSeek(indicesOffs.absOffset + j*8);
                        uint numIDs;
                        uint offset; 
                        FSeek(weightsOffs.absOffset + offset);
                        for (w=0; w<numIDs; w++)
                            struct boneWeight {
                                uint value;
                                FSkip(-4);
                                uint weight : 22;
                                uint boneID : 10;
                                weightTotal += weight;
                            } weight <name=ReadBoneWeightName, read=ReadBoneWeightValue, bgcolor=cPurple>;
                    } vert <name=ReadWeightVertName, read=ReadWeightVert>;
                }
            } BoneIndsWeights;
            FSeek(startof(weightsOffs)+8);
        } skinData <size=32>;
    }

    FSeek(SubmeshInfo.shaderDescOffs.absOffset);
    struct shaderDesc {
        struct {
            if (isTLOU2) {
                StringRead shaderAsset(0);
                StringRead shaderType(0);
                uint64 UUID;
                pointerFixup shaderParamsOffs;
                pointerFixup texHeadersOffs;
                pointerFixup shaderNamesOffs;
                pointerFixup uknOffs;
                pointerFixup fetchMapDescsOffs;
                uint uknData[52];
                uint paramCount;
                uint texCount;
                uint nameCount;
                uint fetchMapCount;
            } else {
                StringRead shaderAsset(0);
                StringRead shaderType(0);
                pointerFixup shaderNamesOffs;
                StringRead hashCodeOffs(0);
                pointerFixup shaderParamsOffs;
                pointerFixup texHeadersOffs;
                pointerFixup fetchMapDescsOffs;
                uint nameCount;
                uint paramCount;
                uint texCount;
                uint fetchMapCount;
                uint uknData[34];
            }
        } ShaderInfo;
        
        FSeek(ShaderInfo.shaderNamesOffs.absOffset);
        if (ShaderInfo.shaderNamesOffs.absOffset)
            struct {
                StringRead name(0)[ShaderInfo.nameCount] <optimize=false>;
            } shaderOptionNames;
        
        FSeek(ShaderInfo.shaderParamsOffs.absOffset);
        if (ShaderInfo.shaderParamsOffs.absOffset)
            struct {
                struct materialParam {
                    StringRead name(0);//[2] <optimize=false>;
                    pointerFixup valueOffs;
                    uint64 numFloats;
                    FSeek(valueOffs.absOffset);
                    for (w=0; w<numFloats; w++)
                        float value <fgcolor=cLtGreen>;
                    FSeek(startof(this)+24);
                } param[ShaderInfo.paramCount] <optimize=false, read=ReadMaterialParam, name=ReadMaterialParamName, write=WriteMaterialParam>;
            } shaderParams;
        
        FSeek(ShaderInfo.texHeadersOffs.absOffset);
        if (ShaderInfo.texHeadersOffs.absOffset)
            struct {
                struct texHeader {
                    StringRead name(0);
                    StringRead path(0);
                    if (isTLOU2)
                        uint64 ukn;
                    pointerFixup texStructOffs;
                    uint64 ukn64_0, ukn64_1;
                    FSeek(texStructOffs.absOffset);
                    struct textureDesc TextureDesc <read=ReadTextureDesc>;
                    FSeek(startof(ukn64_1)+8);
                } TexHeader[ShaderInfo.texCount] <optimize=false, read=ReadTexHeader, name=ReadTexHeaderName>;
            } TexHeaders;
        
        FSeek(ShaderInfo.fetchMapDescsOffs.absOffset);
        if (ShaderInfo.fetchMapDescsOffs.absOffset)
            struct {
                struct {
                    if (isTLOU2) {
                        uint64 hash;
                        pointerFixup uknOffs;
                        uint ukn0;
                        uint ukn1;
                    } else {
                        uint64 hash;
                        uint hash2;
                        uint ukn;
                        uint ukn;
                        uint count;
                        pointerFixup FetchMapsOffs;
                        FSeek(FetchMapsOffs.absOffset);
                        if (FetchMapsOffs.absOffset && count && count*16+FTell() < FileSize())
                            struct {
                                struct wrinkleMap {
                                    uint texHeaderIndex, thisIndex;
                                    StringRead name(0);
                                } FetchMap[count] <optimize=false, read=ReadWrinkleMap>;
                            } FetchMaps;
                        FSeek(startof(this)+32);
                    }
                } FetchMapsDesc[ShaderInfo.fetchMapCount] <optimize=false>;
            } FetchMapsDescs;
        FSeek(startof(this)+208);
    } Material <size=208>;
    
    FSeek(SubmeshInfo.m_pIndexes.absOffset);
    struct {
        ushort A, B, C;
    } faces[SubmeshInfo.m_numIndexes/3] <fgcolor=cYellow>;
    SetBackColor(cNone);
        
    FSeek(startof(SubmeshInfo)+sizeof(SubmeshInfo));
} SubMeshDesc <read=ReadSubMeshDesc>;

    string ReadSubMeshDesc(SubMeshDesc &d) {
        if (exists(d.SubmeshInfo))
            return d.SubmeshInfo.m_name.str;
        return "";
    }

    string ReadStreamDesc(StreamDesc &s) {
        if (exists(s.compInfo))
            return ReadFloatDesc(s.compInfo);
        if (exists(s.T2compInfo))
            return ReadT2FloatDesc(s.T2compInfo);
        return "";
    }

    string ReadFloatDesc(FloatDesc &f) {
        return EnumToString(f.m_floatType);
    }
    string ReadT2FloatDesc(T2FloatDesc &f) {
        SPrintf(s, "%i - %s", f.m_floatType, EnumToString(f.m_floatType));
        return s;
    }


    string ReadBoneWeight(uint w) {
        SPrintf(s, "%f", (float)(w / 4194304.0));
        return s;
    }
    
    string ReadBoneWeightValue(boneWeight &b) {
        return ReadBoneWeight(b.weight);
    }    
    
    string GetBoneNameFromID(ushort id) {
        if (jointsDescId != -1 && exists(Page[jointsPageId].PageEntry[jointsDescId].Item.Joints.names.name[id]))
            return Page[jointsPageId].PageEntry[jointsDescId].Item.Joints.names.name[id].str;
        local string s; SPrintf(s, "%i", id);
        return s;
    }

    string ReadBoneWeightName(boneWeight &b) {
        return GetBoneNameFromID((ushort)b.boneID);
    }

    string ReadBoneIDByte(ubyte id) { return GetBoneNameFromID((ushort)id);}; 

    string ReadWeightVertName(weightVert &v) {
        return ReadBoneWeight(v.weightTotal);
    }

    string ReadWeightVert(weightVert &v) {
        if (exists(v.weight[0]))
            s = ReadBoneWeightName(v.weight[0]);
        else 
            s = ReadBoneWeightName(v.weight);
        for (w=1; w<v.numIDs; w++)
            s = s + ", " + ReadBoneWeightName(v.weight[w]);
        return s;
    }

    string ReadWrinkleMap(wrinkleMap &m) { return m.name.str; }
    
    string ReadTexHeader(texHeader &t) { return t.TextureDesc.tgaPath.str; }

    string ReadTexHeaderName(texHeader &t) { return t.name.str; }

    string ReadMaterialParamName(materialParam &m) { return m.name.str; }

    string ReadMaterialParam(materialParam &m) { 
        local string ss;
        SPrintf(ss, "%g", m.value[0]);
        for (w=1; w<m.numFloats; w++)
            SPrintf(ss, "%s, %g", ss, m.value[w]);
        return ss;
    }

    void WriteMaterialParam(materialParam &m, string array) {
        local ubyte q; 
        local string fmtString;
        local string FMT = "%g";
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<m.numFloats-1; q++)
                fmtString += FMT + " ";
            fmtString += FMT;
        } else {
            for (q=0; q<m.numFloats-1; q++)
                fmtString += FMT + ", ";
            fmtString += FMT;
        }
        if (m.numFloats == 3) 
            SScanf(array, fmtString, m.value[0], m.value[1], m.value[2]);
        else if (m.numFloats == 2) 
            SScanf(array, fmtString, m.value[0], m.value[1]);
        else
            SScanf(array, fmtString, m.value[0]);
    }
    
    string ReadTLOU2Vert(TLOU2Vert &v) {
        local string s;
        if (exists(v.Z)) {
            SPrintf(s, "%g %g %g", v.X, v.Y, v.Z); return s;
        } /*else if (exists(v.Y)) {
            SPrintf(s, "%g %g", v.X, v.Y); return s;
        } else if (exists(v.X)) {
            SPrintf(s, "%g", v.X); return s;
        }*/
        //if (parentof(v).T2compInfo.m_stride == 4)
        SPrintf(s, "%g", (uint)(v.x) * parentof(v).qScale[0] + parentof(v).qOffs[0]);
        if (exists(v.y))
            SPrintf(s, "%s, %g", s, (uint)(v.y) * parentof(v).qScale[1] + parentof(v).qOffs[1]);
        if (exists(v.z)) 
            SPrintf(s, "%s, %g", s, (uint)(v.z) * parentof(v).qScale[2] + parentof(v).qOffs[2]);
        if (exists(v.w)) 
            SPrintf(s, "%s, %g", s, (uint)(v.w) * parentof(v).qScale[3] + parentof(v).qOffs[3]);
        return s;
    }

for (i=0; i<Header.m_pageCt; i++) {
    FSeek(PakPageEntry[i].m_resPageOffset);
    ResPage Page;
}

FSeek(PakPageEntry[Header.m_pageCt-1].m_resPageOffset + PakPageEntry[Header.m_pageCt-1].m_pageSize);

if (Header.m_datasize)
    struct {
        //FSkip(FileSize()-FTell()-1);
        FSkip(Header.m_datasize-1);
        ubyte end;
    } TextureData;

if (geoStart) {
    FSkip(-1);
    BLANK spacer;
    FSeek(geoStart);
    struct GEOMETRY_1 Geometry;
}